<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dev | Gorille Gris]]></title>
  <link href="http://ptitgraig.github.io/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://ptitgraig.github.io/"/>
  <updated>2015-01-08T14:18:45+01:00</updated>
  <id>http://ptitgraig.github.io/</id>
  <author>
    <name><![CDATA[Grégory Pelletey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les pours et contres des frameworks JS]]></title>
    <link href="http://ptitgraig.github.io/blog/2015/01/05/les-pours-et-contres-des-frameworks-js/"/>
    <updated>2015-01-05T18:04:00+01:00</updated>
    <id>http://ptitgraig.github.io/blog/2015/01/05/les-pours-et-contres-des-frameworks-js</id>
    <content type="html"><![CDATA[<p class="foreword">
Les pours et les contres des framework BackboneJS, AngularJS, EXTJS, EmberJS : pour t'aider à choisir dans cette jungle.
</p>
<!-- more -->

<h2 id="backbonejs">Backbone.js</h2>

<p>Pours :</p>

<ul>
  <li>
    <p>Simplicité - seulement 4 composants (Collection, Model, View, Router).</p>
  </li>
  <li>
    <p>Très grosse communauté et beaucoup de solutions sur Stackoverflow.</p>
  </li>
  <li>
    <p>Couche supérieures codés intelligemment comme Marionnette et Vertebae.</p>
  </li>
  <li>
    <p>L’architecture de ton application peut être personnalisée.</p>
  </li>
  <li>
    <p>Léger et mis à jour régulièrement. S’entend bien avec Underscore, jQuery/Zepto - des librairies très répendues.</p>
  </li>
  <li>
    <p>Fourni un niveau d’ abstraction suffisant avec prise de position raisonnable, permettant une adapation au plus proche des besoins du projet.</p>
  </li>
  <li>
    <p>Facile à prendre en main, offrant un bon tremplin pour les framework MV* Javascript.</p>
  </li>
  <li>
    <p>Compatibilité avec d’anciens navigateurs : IE7, 8 t même 6 (on osera tout de même pas aller jusque là).</p>
  </li>
</ul>

<p>Contres :</p>

<ul>
  <li>
    <p>La méthode extend copie le contenu de l’objet parent dans une nouvel objet. Bénéficier de l’héritage prototypal aurait été préférable.</p>
  </li>
  <li>
    <p>Manque de cas réel d’utilisation dans la documentation</p>
  </li>
  <li>
    <p>L’application TODO met le pied à l’étrier mais il y a encore beaucoup à apprendre après pour construire de grosses applications.</p>
  </li>
  <li>
    <p>La quantité de didacticiels sur comment faire les choses avec Backbone n’est pas cohérente et décrivrent des choses à différentes périodes de la vie de Backbone. Dand une équipe, des développeurs peuvent coder les choses à la façcon Backbone 0.3 alors que nous en sommes à une version antérieur à 1.</p>
  </li>
  <li>
    <p>Quelques reserves sur Backbone.sync qui pose contient dans son code des hypothèses concernant les communications typique HTTP déclenché par un clien. Ca ne s’adapte pas bien à la nature des WebSockets.</p>
  </li>
  <li>
    <p>Il n’y a pas, par défaut, de binding de view. Un re-rendu de la view alors qu’une simple propriété change semble être un peu du gâchi.</p>
  </li>
</ul>

<h2 id="angularjs">Angular.js</h2>

<p>Pours : </p>

<ul>
  <li>
    <p>Two-way data binding (système de liaison des données en deux sens) est extremement puissant. On pense donc d’avantage au model et à son état qu’à une série d’événements à déclencher. Le model est la seul source de vérité.</p>
  </li>
  <li>
    <p>Performance. AngularJS coûte peu en téléchargement. Son moteur de template utilise les noeuds du DOM au lieu de convertir des String en noeud. Ce qui doit améliorer les performances.</p>
  </li>
  <li>
    <p>Si tu cibles les navigateurs récents et que tu ne te soucis pas, ou peu, des anciens navigateurs, tu peux supprimer jQuery de tes dépendances.</p>
  </li>
  <li>
    <p>Intuitif, excellente documentation. Système de liaison des données ingénieux : Vue (view) HTML, portées (scope) imbriquées.</p>
  </li>
  <li>
    <p>Une extension Chrome, Batarang, qui fourni un accès en direct aux structures de données Angular.</p>
  </li>
  <li>
    <p>Minimisation du code de réutilisable (boilerplate code). Permet la réutilisation du code grâce à des composants. Etend la syntaxe HTML de sorte que de nombreuses fonctionnalités complexes finissent par êre aussi simple que la mise en place d’une directive (attribut) dans le code HTML. </p>
  </li>
  <li>
    <p>Très facilement testable grâce au système d’injection de dépendance.</p>
  </li>
  <li>
    <p>Ecrire une application complexe dans jQuery qui manipule le DOM : c’est déjà un petit exploit.</p>
  </li>
</ul>

<p>Contres :</p>

<ul>
  <li>
    <p>On ne peut pas, d’une manière simplement déclarative, spécifier une transition pour un changement d’UI qui vient d’un changement dans le model.</p>
  </li>
  <li>
    <p>Courbe d’apprentissage plus raide que Backbone, mais le gain est appréciable. </p>
  </li>
  <li>
    <p>La documentation pourrait être améliorée.</p>
  </li>
</ul>

<p>Largement inspiré de l’article de Smashing Magazine : 
<a href="http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/">Journey Through The JavaScript MVC Jungle</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[S'y retrouver dans les outils de test Javascript]]></title>
    <link href="http://ptitgraig.github.io/blog/2015/01/05/sy-retrouver-dans-les-outils-de-test-javascript/"/>
    <updated>2015-01-05T14:21:00+01:00</updated>
    <id>http://ptitgraig.github.io/blog/2015/01/05/sy-retrouver-dans-les-outils-de-test-javascript</id>
    <content type="html"><![CDATA[<p class="foreword">
Entre Jasmine, Sinon.js, Karma, QUnit tu ne sais plus où donner de la tête ? Voici un bref récapitulatif des outils pour tester du Javascript.
Cet article sera enrichi au fur et à mesure des mes connaissances sur les sujets.
</p>
<!-- more -->

<h2 id="dfinitions">Définitions</h2>

<h3 id="test-driven-development-tdd">Test-Driven Development (TDD)</h3>

<p>Le Test Driven Development (TDD) ou en français développement piloté par les tests est une technique de développement de logiciel qui préconise d’écrire les tests unitaires avant d’écrire le code source d’un logiciel <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>Le cycle préconisé par TDD comporte 5 étapes :</p>

<ol>
  <li>écrire un premier test;</li>
  <li>vérifier qu’il échoue (car le code qu’il teste n’existe pas), afin de vérifier que le test est valide;</li>
  <li>écrire juste le code suffisant pour passer le test;</li>
  <li>vérifier que le test passe;</li>
  <li>puis refactoriser le code.</li>
</ol>

<p>Les intérêts :</p>

<ul>
  <li>facilite la production de code valide en toutes circonstances</li>
  <li>on utilise le programme avant même qu’il existe</li>
  <li>évite des erreurs de conceptions dues à la précipitation avant d’avoir défini les objectifs</li>
  <li>plus grande assurance lors du refactoring, tu sais que les tests ont fonctionné à un moment donné. Tu peux ainsi te permettre des changements radicaux dans le code</li>
</ul>

<p>Une chose importante est que les demandeurs doivent formaliser la manière dont ils testeront la fonctionnalité. C’est le travail du responsable applicatif de s’en assurer.</p>

<h3 id="behavior-driven-development-bdd">Behavior-Driven Development (BDD)</h3>

<p>Behavior Driven Development (ou BDD) est une méthode Agile qui encourage la collaboration entre les développeurs, les responsables qualités, les intervenants non-techniques et les entreprises participant à un projet de logiciel. Il a été conçu en 2003 par Dan North comme une réponse au Test Driven Development. <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>Le processus BDD met en avant le langage naturel et les interactions dans le processus de développement logiciel. Les développeurs utilisant le BDD utilisent leur langue maternelle en combinaison avec le langage du domaine Domaine Driven Design pour décrire l’objectif et le bénéfice de leur code. Cela permet aux développeurs de se concentrer sur les raisons pour lesquelles le code doit être créé, plutôt que les détails techniques, et minimise la traduction entre le langage technique dans lequel le code est écrit et le domaine de la langue parlée par les entreprises, les utilisateurs, les intervenants, la gestion de projet etc…</p>

<p>Dans la pratique :</p>

<ul>
  <li>on utilise des exemples pour décrire le comportement de la demande;</li>
  <li>on automatise ces exemples pour fournir rapidement des commentaires ou tests de non-regression;</li>
  <li>on utilise le mot ‘devrait’, ce qui contribue à clarifier la résponsabilité et permet la remise en cause de la fonctionnalité de l’application;</li>
  <li>on utilise ‘verifier que’, ce qui permet de faire la différence entre les résultats provenant du champ d’application du code et d’autres éléments du code;</li>
  <li>on utilise des ‘mocks’ (fausse fonction) en remplacant des modules de code qui ne sont pas encore écrits.</li>
</ul>

<h3 id="les-bibliotques-dnoncs-assertions-library">Les bibliotèques d’énoncés (assertions library)</h3>

<p>Une assertion est un énoncé considéré comme vrai. Les bibliothèques d’énoncés permettent de formuler les tests de manière compréhensible.
Quelques bibliothèques d’énoncés :
* should.js
* expect.js
* chai.js</p>

<h3 id="les-frameworks-de-test">Les frameworks de test</h3>

<p>Un framework de test engloble une ou plusieurs bibliothèques d’énoncés, permet de lancer des tests.</p>

<p>A compléter…</p>

<h2 id="les-outils">Les outils</h2>

<h3 id="jasmine">Jasmine</h3>

<p><img class="left" src="/images/test-jasmine.png" width="140" height="140">
Jasmine est un <em>framework de test</em> JavaScript developpement orienté comportement (BDD). Il ne dépend d’aucun autre framework JavaScript.
Il ne requiert pas un DOM et possède une syntaxe propre et évidente, ce qui permet d’écrire facilement tes tests.</p>

<h3 id="mocha">Mocha</h3>

<p><img class="left" src="/images/test-mocha.png" width="140" height="140">
Mocha est un <em>framework de test</em> JavaScript riche en fonctionnalités, basé sur Node.js et sur le navigateur, qui rend les tests asynchrones simple et agréable. Les tests Mocha se déroulent de manière séquentielle, ce qui permet d’établir un rapporte précis et flexible, tout en faisant concorder les exceptions non interceptées au bon cas de test.</p>

<h3 id="karma-anciennement-testacular">Karma (anciennement Testacular)</h3>

<p><img class="left" src="/images/test-karma.png" width="140" height="140">
Karma est un <em>environnement de test</em>. Le but principal de Karma est d’offrir aux développeurs un environnement de test productif. Plutôt que de demander de mettre en place tout un tas de configurations, Karma te permet d’écire le code est d’obtenir un retour instantané de tes tests. La philosphie de Karma est : une retour rapide sur ton code, c’est ce qui te rend productif et créatif. C’est une opinion.</p>

<p>Karma est essentiellement un outil qui génère un serveur Web qui exécute le code source en se basant sur le code de test, et ce pour chaque navigateurs connectés. Les résultats de chaque test contre sur chaque navigateur sont calculées et affichées sur la ligne de commande de telle sorte que tu puisses voir quels sont les tests qui ont réussis et échoués, et ce sur chaque navigateur.
Tu peux tester le résulat sur un navigateur soit manuellement, en visitant l’URL écoutée par le serveur Karma (habituellement http://localhost:9876/), soit
automatiquement en configurant Karma de sorte qu’il sache quel navigateur démarrer quand Karma est exécuté.</p>

<p>Karma surveille aussi tous les fichiers listés dans le fichier de configuration. Dès qu’un fichier change, Karma déclenche les tests en envoyant un signal 
au serveur de test pour informer tout les navigayeurs connectés d’executer le code de test à nouveau. Chaque navigateur charge ensuite le code source dans une IFrame, exécute les tests, et rapporte les résultats au serveur.
Le serveur collecte les résultats de l’ensemble des navigateurs connectés et te les présente.</p>

<h3 id="intern">Intern</h3>

<p><img class="left" src="/images/test-intern.png" width="140" height="140">
Intern est <em>une pile de test complète pour Javascript</em>, conçue pour t’aider à écrire et exécuter des cas de test, pour applications et biblothèques de scripts, cohérent et de haute qualité. Intern peut être utilisé pour tester n’importe quel code JavaScript. Ses capacités de test fonctionnel peuvent même être utilisé pour tester des applications mobile et web non JavaScript - si tu le veux vraiment.</p>

<h3 id="sinonjs">sinon.js</h3>

<p>Espions de test autonome et mocks pour JavaScript.
Aucune dépendances, fonctionne avec n’importe quel framework JavaScript.
Un espion de test est une fonction qui enregistre les paramètres, retourne la valeur de <code>this</code> et l’exception levée - si présente.
Un espion de test peut être une fonction anonyme ou peut être encapsuler dans une autre fonction.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="string"><span class="delimiter">&quot;</span><span class="content">test should call subscribers on publish</span><span class="delimiter">&quot;</span></span>: <span class="keyword">function</span> () {
    <span class="keyword">var</span> callback = sinon.spy();
    PubSub.subscribe(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>, callback);

    PubSub.publishSync(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>);

    assertTrue(callback.called);
}
</pre></div>
</div>
</div>

<h3 id="shouldjs">should.js</h3>

<p>Enoncés (assertions) de style Behavior-Driven-Developemnt (BDD) pour Node.js, indépendant de tout framework de test.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> should = require(<span class="string"><span class="delimiter">'</span><span class="content">should</span><span class="delimiter">'</span></span>);

<span class="keyword">var</span> user = {
    <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">tj</span><span class="delimiter">'</span></span>
  , <span class="key">pets</span>: [<span class="string"><span class="delimiter">'</span><span class="content">tobi</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">loki</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">jane</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">bandit</span><span class="delimiter">'</span></span>]
};

user.should.have.property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">tj</span><span class="delimiter">'</span></span>);
user.should.have.property(<span class="string"><span class="delimiter">'</span><span class="content">pets</span><span class="delimiter">'</span></span>).<span class="keyword">with</span>.lengthOf(<span class="integer">4</span>);

<span class="comment">// Si l'objet a été créé avec Object.create(null)</span>
<span class="comment">// alors il n'hérite pas de `Object.prototype`, donc il n'aura pas une getter `.should`</span>
<span class="comment">// donc tu peux faire :</span>
should(user).have.property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">tj</span><span class="delimiter">'</span></span>);

<span class="comment">// aussi, tu peux tester de cette manières les `null`</span>
should(<span class="predefined-constant">null</span>).not.be.ok;

someAsyncTask(foo, <span class="keyword">function</span>(err, result){
  should.not.exist(err);
  should.exist(result);
  result.bar.should.equal(foo);
});
</pre></div>
</div>
</div>

<h3 id="expectjs">expect.js</h3>

<p>Outils d’enoncés minimalistes de style BDD pour Node.JS et pour navigateurs, basé sur should.js</p>

<ul>
  <li>Cross-browser : fonctionne sur IE6+, Firefox, Safari, Chrome, Opera.</li>
  <li>Compatible avec tous les frameworks de test.</li>
  <li>Prête pour Node.JS (require(‘expect.js’)).</li>
  <li>Autonome. Global seule sans extensions de prototype ou brique (shims)</li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre>expect(window.r).to.be(<span class="predefined-constant">undefined</span>);
expect({ <span class="key">a</span>: <span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span> }).to.eql({ <span class="key">a</span>: <span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span> })
expect(<span class="integer">5</span>).to.be.a(<span class="string"><span class="delimiter">'</span><span class="content">number</span><span class="delimiter">'</span></span>);
expect([]).to.be.an(<span class="string"><span class="delimiter">'</span><span class="content">array</span><span class="delimiter">'</span></span>);
expect(window).not.to.be.an(Image);
</pre></div>
</div>
</div>

<h3 id="chaijs">chai.js</h3>

<p><img class="left" src="/images/test-chai.png" width="140" height="140">
Chai est une bibliothèque d’énoncés BDD / TDD pour node.js et les navigateurs qui peut être couplé à n’importe quel framework de test JavaScript</p>

<h3 id="qunit">qUnit</h3>

<p>A venir.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>http://fr.wikipedia.org/wiki/Test_Driven_Development<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>http://fr.wikipedia.org/wiki/Behavior_Driven_Development<a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La base de Spring MVC]]></title>
    <link href="http://ptitgraig.github.io/blog/2015/01/05/la-base-de-spring-mvc/"/>
    <updated>2015-01-05T12:49:00+01:00</updated>
    <id>http://ptitgraig.github.io/blog/2015/01/05/la-base-de-spring-mvc</id>
    <content type="html"><![CDATA[<p class="foreword">
Fonctionnement basique du framework JAVA Spring MVC. Très bon pour la culture générale d'un développeur front.
</p>
<!-- more -->

<h2 id="fonctionnement">Fonctionnement</h2>

<p>Le framework Spring Web MVC est conçu autour d’une DispatcherServlet qui gère toutes les requêtes et réponses HTTP. Illustration ci-dessous :</p>

<p><img src="/images/spring_dispatcherservlet.png"></p>

<ol>
  <li>
    <p>Après avoir reçu une requête HTTP, DispatchServlet consulte le HandlerMapping pour appeler le Controller approprié.</p>
  </li>
  <li>
    <p>Le Controller analyse la requête et apelle le la méthode du service appropriée, basé l’utilisation des méthodes POST ou GET. La méthode du service initialisera les données du model sur la base d’une logique business puis retournera ne nom de la vue à la DispatcherServlet</p>
  </li>
  <li>
    <p>La DispatcherServlet s’appuiera sur la ViewResolver pour choisir la bonne vue pour la requête</p>
  </li>
  <li>
    <p>Une fois que la vue est finalisée, la DispatcherServlet passe les données du model à la vue, cette dernière étant finalement affichée sur le navigateur.</p>
  </li>
</ol>

<p>Tous les composants mentionnés ci-dessus (HandlerMapping, Controller et ViewResolver) font partis du WebApplicationContext, lequel est une extention du ApplicationContext auquel on a ajouté quelques caractéristiques supplémentaires pour les applications web.</p>

<h2 id="spring-mvc-pour-faire-du-rest">Spring MVC pour faire du REST</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment bien calculer le poids d'un selecteur CSS]]></title>
    <link href="http://ptitgraig.github.io/blog/2014/06/18/comment-bien-calculer-le-poids-dun-selecteur-css/"/>
    <updated>2014-06-18T10:13:00+02:00</updated>
    <id>http://ptitgraig.github.io/blog/2014/06/18/comment-bien-calculer-le-poids-dun-selecteur-css</id>
    <content type="html"><![CDATA[<p class="foreword">
Voici un article qui vous expliquera le poids des CSS. Cela est utile quand vous voulez surcharger un style, comprendre quel style s'applique à quel élément et pourquoi un style s'applique plutôt qu'un autre.
</p>
<!-- more -->

<p>Quand vous reprenez un projet existant, qui date déjà un peu, vous vous retrouvez souvent avec des déclarations CSS à rallonge et ne savait plus quoi s’applique à quoi.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="class">.container</span> <span class="class">.info</span><span class="class">.test</span> <span class="class">.spanner</span> <span class="class">.wrapper</span> <span class="class">.block</span> <span class="tag">div</span><span class="class">.pictos</span> <span class="id">#jailanausee</span> { <span class="key">color</span> : <span class="color">#000</span>; }
</pre></div>
</div>
</div>

<p>Pour éviter je genre de massacre, il est d’une extrème importance de comprendre quel style va s’appliquer à quel élement, et dans quel ordre.
Prenons un exemple. Parmi ces quelques déclarations, laquelle va remporter le combat et s’appliquer au span. Quelle va être la couleur du texte du span : rouge, bleu, vert ou jaune ?</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="id">#idSpan</span> { <span class="key">color</span>: <span class="value">red</span>; }
<span class="tag">span</span><span class="class">.class-span</span> { <span class="key">color</span>: <span class="value">orange</span>; }
<span class="class">.bloc</span><span class="class">.info</span> <span class="tag">span</span> { <span class="key">color</span>: <span class="value">yellow</span>; }
<span class="class">.container</span> <span class="class">.bloc</span><span class="class">.info</span> <span class="class">.class-txt</span> <span class="tag">span</span><span class="class">.class-span</span> { <span class="key">color</span>: <span class="value">green</span>; }
<span class="tag">span</span> { <span class="key">color</span>: <span class="value">blue</span> <span class="important">!important</span> }
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre><span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">container</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;div</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">block info</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;span</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">class-span</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">idSpan</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">style</span>=<span class="string"><span class="delimiter">&quot;</span><span class="key">color</span>:<span class="value">purple</span>;<span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
            je suis d'une certaine couleur
        <span class="tag">&lt;/span&gt;</span>
    <span class="tag">&lt;/div&gt;</span>
<span class="tag">&lt;/div&gt;</span>
</pre></div>
</div>
</div>

<p>La réponse est bleu ! <a href="http://jsfiddle.net/ptitgraig/L8CUS/2/">La preuve ici</a>.</p>

<p>Voici un court explicatif de l’ordre d’application des styles sur le span.</p>

<table>
	
		<td>
			!important
		</td>
		<td>
			attribut style (style="")
		</td>
		<td>
			nombre d'id (#)
		</td>
		<td>
			nombre de classes (.)
		</td>
		<td>
			nombre de balises
		</td>
	
	<tr>
		<td>
			gagne sur tous les autres style, même seul
		</td>
		<td>
			0 .. n
		</td>
		<td>
			0 .. n
		</td>
		<td>
			0 .. n
		</td>
		<td>
			0 .. n
		</td>
	</tr>
</table>

<p>Au final, vous vous trouvez avec un chiffre entre 0 et 19999. Reprenons notre exemple de départ. Sachant que l’attribut style s’applique toujours et annule les autres, nous allons nous en affranchir pour l’exemple.</p>

<table>
	<tr>
		<th>Déclaration CSS</th>
		<th>!important</th>
		<th>nombre d'id (#)</th>
		<th>nombre de classes (.)</th>
		<th>nombre de balises</th>
		<th>poids</th>
	</tr>
	<tr>
		<td>#idSpan</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0100</td>
	</tr>
	<tr>
		<td>span.class-span</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>0011</td>
	</tr>
	<tr>
		<td>.bloc.info span</td>
		<td>0</td>
		<td>0</td>
		<td>2</td>
		<td>1</td>
		<td>0021</td>
	</tr>
	<tr>
		<td>.container .bloc.info .class-txt span.class-span</td>
		<td>0</td>
		<td>0</td>
		<td>5</td>
		<td>1</td>
		<td>0051</td>
	</tr>
	<tr>
		<td>span (avec !important)</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1001</td>
	</tr>
</table>

<p>Au final vous voyez l’ordre d’importance se déssiner :</p>

<ol>
  <li>span (avec !important) /* 1001 */</li>
  <li>#idSpan /* 0100 */</li>
  <li>.container .bloc.info .class-txt span.class-span /* 0051 */</li>
  <li>.bloc.info span /* 0021 */</li>
  <li>span.class-span /* 0011 */</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memento Backbone.js]]></title>
    <link href="http://ptitgraig.github.io/blog/2014/02/05/memento-backbone-dot-js/"/>
    <updated>2014-02-05T17:26:00+01:00</updated>
    <id>http://ptitgraig.github.io/blog/2014/02/05/memento-backbone-dot-js</id>
    <content type="html"><![CDATA[<p>Backbone est un framework javascript MVC qui permet de construire des applications de type Single-Page-Webapp.</p>

<p>En vérité il s’agit plutôt d’un framework MV* car le Controller n’existe pas vraiment dans Backbone.</p>

<p>Faisons un parrallèle entre un MVC classique et un MVC Backbone.
<!-- more --></p>

<h2 id="models">Models</h2>

<ul>
  <li>C’est là ou se fait la validation des données.</li>
  <li>Sont persistés soit par du localStorage ou bien par synchronisation avec une base de données.</li>
  <li>Plusieurs Views peuvent observer des changements sur un Model. Une View, en effet, regarde un Model et peut ainsi savoir quand un Model a changé et afficher les infos à jour du Model.</li>
  <li>Un ensemble de Models est appelé une Collection. Dès qu’un Model dans cette Collection change, la View attachée à ce Model est notifiée.</li>
</ul>

<h2 id="controllers">Controllers</h2>

<ul>
  <li>N’existe pas. La View joue le rôle de Controller.</li>
  <li>Gérer les changements effectués dans la vue par l’utilisateur</li>
  <li>Mettre à jour le Model quand un utilisateur a terminé ses actions</li>
</ul>

<h2 id="views">Views</h2>

<ul>
  <li>C’est là que les utilisateurs cliquent et font mumuse.</li>
  <li>Donc c’est là qu’on lit / edite / supprime les données d’un Model.</li>
  <li>Il y a une fonction <code>render()</code> qui doit s’occuper d’afficher le contenu du Model (ça utilise le moteur de template de Underscore.js). On l’utilise en callback afin de notifier la View de potentiels changements sur le Model.</li>
  <li>Dans le code, on fait référence à la vue avec <code>this.el</code></li>
  <li>Quand un utilisateur clique dans la View, c’est normalement le Controller qui s’occupe du traitement a effectuer, mais comme on l’a vu, il n’y a pas de Controller dans Backbone. Les évenements sont gérés dans la View grâce à un objet <code>event : {}</code></li>
</ul>

<h2 id="pense-bte-pour-le-model">pense-bête pour le Model</h2>

<h3 id="mthodes-native--backbone">Méthodes native à Backbone</h3>

<ul>
  <li>set : pour changer ou initialiser un attribut du Model <code>myModel.set('toto', 'un valeur');</code></li>
  <li>get : pour obtenir la valeur d’un attribut du Model <code>myModel.get('toto');</code></li>
  <li>validate : permet de valider le model ex :</li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre><span class="function">validate</span>: <span class="keyword">function</span>(attributes){
    <span class="keyword">if</span>(attributes.title === <span class="predefined-constant">undefined</span>){
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Remember to set a title for your todo.</span><span class="delimiter">&quot;</span></span>;
    }
},
</pre></div>
</div>
</div>

<h3 id="ecouter-si-le-modle-change-">ecouter si le modèle change :</h3>

<div><div class="CodeRay">
  <div class="code"><pre><span class="local-variable">this</span>.on(<span class="string"><span class="delimiter">'</span><span class="content">change</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>(){ 
    <span class="comment">//faire quelquechose</span>
});
</pre></div>
</div>
</div>

<h3 id="ecouter-si-lattribut-toto-du-model-change--thisonchangetoto">ecouter si l’attribut toto du model change : <code>this.on('change:toto')</code></h3>

<h2 id="pense-bte-pour-la-view">pense-bête pour la View</h2>

<p>La méthode <code>render()</code> de la View peut être liée à la méthode <code>change()</code> du Model. Ainsi dès qu’il y a un changement dans le Model, la View refléte immédiatement ces changements.</p>

<h3 id="setelement">setElement()</h3>

<p>Colle un template HTML a une vue.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> view = <span class="keyword">new</span> Backbone.View;
view.setElement(<span class="string"><span class="delimiter">'</span><span class="content">&lt;p&gt;&lt;a&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;</span><span class="delimiter">'</span></span>);
view.el <span class="comment">// &lt;p&gt;&lt;a&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;</span>
</pre></div>
</div>
</div>

<h3 id="render">render()</h3>

<p>A la fin de render() il est bien de faire <code>return this</code> car :</p>

<ul>
  <li>la View peut être réutiliser par des View parent</li>
  <li>Créer une liste d’éléments sans repeindre chacun individuellement, l’élément est déssiné une fois par le navigateur et la liste entière est remplie en données (sens peu claire)</li>
</ul>

<h2 id="pense-bte-collection">pense-bête Collection</h2>

<h3 id="syntaxe">Syntaxe</h3>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> Todo = Backbone.Model.extend({});

<span class="keyword">var</span> TodosCollection = Backbone.Collection.extend({
  <span class="key">model</span>: Todo
});
</pre></div>
</div>
</div>

<h3 id="ajout-suppression-de-models">Ajout suppression de Models</h3>

<p>Une fois la Collection créée, on peut supprimer ou ajouter des Models à la Collection avec : <code>add()</code> et <code>remove()</code>. Ces 2 méthodes acceptent un ou plusieurs model en paramètre (sous forme de tableau [])</p>

<h3 id="retrouver-un-model">Retrouver un Model</h3>

<p><code>Collection.get(id)</code> avec id l’id du Model</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> myTodo = <span class="keyword">new</span> Todo({<span class="key">title</span>:<span class="string"><span class="delimiter">'</span><span class="content">Read the whole book</span><span class="delimiter">'</span></span>, <span class="key">id</span>: <span class="integer">2</span>});
<span class="keyword">var</span> todos = <span class="keyword">new</span> TodosCollection([myTodo]);
<span class="keyword">var</span> todo2 = todos.get(<span class="integer">2</span>);
</pre></div>
</div>
</div>

<p>Afin d’intentifier le Model récupéré on peut utiliser : <code>id</code> <code>cid</code> <code>idAttribute</code></p>

<p>Chaque Model a un <code>id</code> qui est unique (type Integer ou String)
<code>idAttribute</code> est l’attribut qui identifie le Model dans la database (<code>id</code> dans la base de donnée). Ca dit a Backbone quel champ de la base de donnée doit être remplir avec la propriété <code>id</code>. Exemple <code>userId</code> dans la base donnera un <code>userId</code> dans la définition du Model dans Backbone.</p>

<h3 id="ecouter-des-vnements">Ecouter des événements</h3>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> TodosCollection = <span class="keyword">new</span> Backbone.Collection();
TodosCollection.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">change:title</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span>(model) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">J'ai changer d'avis, je devrais </span><span class="delimiter">&quot;</span></span> + model.get(<span class="string"><span class="delimiter">'</span><span class="content">title</span><span class="delimiter">'</span></span>));
});
TodosCollection.add([
  { <span class="key">title</span>: <span class="string"><span class="delimiter">'</span><span class="content">go to Jamaica.</span><span class="delimiter">'</span></span>, <span class="key">completed</span>: <span class="predefined-constant">false</span>, <span class="key">id</span>: <span class="integer">3</span> },
]);
<span class="keyword">var</span> myTodo = TodosCollection.get(<span class="integer">3</span>);
myTodo.set(<span class="string"><span class="delimiter">'</span><span class="content">title</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">aller nager</span><span class="delimiter">'</span></span>);
</pre></div>
</div>
</div>

<p>Va afficher : J’ai changer d’avis, je devrais aller nager</p>

<p>On peut écouter si il y a du changement dans une collection (ajout suppression modification) :</p>

<div><div class="CodeRay">
  <div class="code"><pre>TodosCollection.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">add</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span>(model) {
  console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ajouté </span><span class="delimiter">&quot;</span></span> + model.get(<span class="string"><span class="delimiter">'</span><span class="content">title</span><span class="delimiter">'</span></span>));
});
TodosCollection.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">remove</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span>(model) {
  console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Supprimé </span><span class="delimiter">&quot;</span></span> + model.get(<span class="string"><span class="delimiter">'</span><span class="content">title</span><span class="delimiter">'</span></span>));
});

TodosCollection.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">change:completed</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span>(model) {
  console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Changement de l'attribute completed </span><span class="delimiter">&quot;</span></span> + model.get(<span class="string"><span class="delimiter">'</span><span class="content">title</span><span class="delimiter">'</span></span>));
});
TodosCollection.set([
    { <span class="key">id</span>: <span class="integer">1</span>, <span class="key">title</span>: <span class="string"><span class="delimiter">'</span><span class="content">go to Jamaica.</span><span class="delimiter">'</span></span>, <span class="key">completed</span>: <span class="predefined-constant">true</span> },
    { <span class="key">id</span>: <span class="integer">2</span>, <span class="key">title</span>: <span class="string"><span class="delimiter">'</span><span class="content">go to China.</span><span class="delimiter">'</span></span>, <span class="key">completed</span>: <span class="predefined-constant">false</span> },
    { <span class="key">id</span>: <span class="integer">4</span>, <span class="key">title</span>: <span class="string"><span class="delimiter">'</span><span class="content">go to Disney World.</span><span class="delimiter">'</span></span>, <span class="key">completed</span>: <span class="predefined-constant">false</span> }
]);
</pre></div>
</div>
</div>

<p>Vider une Collection : <code>myCollection.reset()</code></p>

<p>Ecouter le vidage d’une Collection : myCollection.on(“reset”, function)</p>

<p>Faire un <code>set()</code> d’une Collection peut provoquer des <code>remove()</code> ou <code>add()</code> en fonction de ce qui est setté</p>

<p>Fonctionnalités hérité d’Underscore :
- <code>forEach</code>
- <code>sortBy</code>
- <code>map</code>
- <code>min/max</code> :</p>

<div><div class="CodeRay">
  <div class="code"><pre>Todos.max(<span class="keyword">function</span>(model){
  <span class="keyword">return</span> model.id;
}).id;
</pre></div>
</div>
</div>

<ul>
  <li><code>pluck</code></li>
</ul>

<p><code>chain()</code> permet de chainer l’appel de fonction sur une Collection</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> collection = <span class="keyword">new</span> Backbone.Collection([
  { <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Tim</span><span class="delimiter">'</span></span>, <span class="key">age</span>: <span class="integer">5</span> },
  { <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Ida</span><span class="delimiter">'</span></span>, <span class="key">age</span>: <span class="integer">26</span> },
  { <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Rob</span><span class="delimiter">'</span></span>, <span class="key">age</span>: <span class="integer">55</span> }
]);

<span class="keyword">var</span> filteredNames = collection.chain() <span class="comment">// start chain, returns wrapper around collection's models</span>
  .filter(<span class="keyword">function</span>(item) { <span class="keyword">return</span> item.get(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>) &gt; <span class="integer">10</span>; }) <span class="comment">// returns wrapped array excluding Tim</span>
  .map(<span class="keyword">function</span>(item) { <span class="keyword">return</span> item.get(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>); }) <span class="comment">// returns wrapped array containing remaining names</span>
  .value(); <span class="comment">// terminates the chain and returns the resulting array</span>

console.log(filteredNames); <span class="comment">// logs: ['Ida', 'Rob']</span>
</pre></div>
</div>
</div>

<h2 id="persistence-restful">Persistence RESTful</h2>

<h3 id="rcuprr-un-model-du-serveur">Récupérér un Model du serveur</h3>

<p><code>Collection.fetch()</code> retrouve un ensemble de Models du server sous la form d’un tableau JSON en envoyant une requête HTTP GET vers l’URL spécifié par la propriété <code>url</code> de la Collection. Quand les données sont récupérées, la fonction <code>set()</code> va être exécuté pour mettre à jour la Collection.</p>

<h3 id="sauvegarder-un-model-sur-le-serveur">Sauvegarder un Model sur le serveur</h3>

<p>On utilise la méthode <code>save()</code> du Model que l’on veut sauvegarder.
- Quand <code>save()</code> est appelé sur un Model qui a été récupérer du serveur avec la méthode <code>fetch()</code>, un requête HTTP PUT est envoyée.
- Si le Model est une nouvelle instance, une requête HTTP POST est envoyé à l’URL de la Collection.</p>

<h3 id="supprimer-un-model-du-serveur">Supprimer un Model du serveur</h3>

<p>Avec <code>destroy()</code> : envoie une requête HTTP DELETE</p>

<h3 id="options">Options</h3>

<p>Il est possible de passer seulement les choses que l’on veut mettre à jour dans un Model et pas forcememnt tout le Model (requête HTTP PATCH). Par exemple :</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="comment">// Sauvegarde partielle avec PATCH</span>
model.clear().set({<span class="key">id</span>: <span class="integer">1</span>, <span class="key">a</span>: <span class="integer">1</span>, <span class="key">b</span>: <span class="integer">2</span>, <span class="key">c</span>: <span class="integer">3</span>, <span class="key">d</span>: <span class="integer">4</span>});
model.save();
model.save({<span class="key">b</span>: <span class="integer">2</span>, <span class="key">d</span>: <span class="integer">4</span>}, {<span class="key">patch</span>: <span class="predefined-constant">true</span>});
console.log(<span class="local-variable">this</span>.syncArgs.method);
<span class="comment">// 'patch'</span>
</pre></div>
</div>
</div>

<h2 id="events">Events</h2>

<h3 id="on-off-trigger">on() off() trigger()</h3>

<p><code>Backbone.Events</code> peut donner à un objet la capacité de lié et déclencher des événements personnalisés.</p>

<p><code>on()</code> lie une fonction callback à un objet. Le callback est appelé à chaque fois que l’événement est déclenché.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> myObject = {};

<span class="comment">// Mixin</span>
_.extend(myObject, Backbone.Events);

<span class="comment">// Ajouter un événement personnalisé</span>
myObject.on(<span class="string"><span class="delimiter">'</span><span class="content">dance</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>(msg){
  console.log(<span class="string"><span class="delimiter">'</span><span class="content">Déclenchement de </span><span class="delimiter">'</span></span> + msg);
});

<span class="comment">// Trigger the custom event</span>
myObject.trigger(<span class="string"><span class="delimiter">'</span><span class="content">dance</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">our event</span><span class="delimiter">'</span></span>);
</pre></div>
</div>
</div>

<p><code>off()</code> supprime toutes les fonctions de callback sur un objet</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="comment">// Removes event bound to the object</span>
myObject.off(<span class="string"><span class="delimiter">&quot;</span><span class="content">dance:tap</span><span class="delimiter">&quot;</span></span>);
</pre></div>
</div>
</div>

<p>Pour supprimer une callback en particulier :</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> ourObject = {};

<span class="comment">// Mixin</span>
_.extend(ourObject, Backbone.Events);

<span class="keyword">function</span> <span class="function">dancing</span> (msg) { console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">We are dancing. </span><span class="delimiter">&quot;</span></span> + msg); }
<span class="keyword">function</span> <span class="function">jumping</span> (msg) { console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">We are jumping. </span><span class="delimiter">&quot;</span></span> + msg); }

<span class="comment">// Add two listeners to the same event</span>
ourObject.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">move</span><span class="delimiter">&quot;</span></span>, dancing);
ourObject.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">move</span><span class="delimiter">&quot;</span></span>, jumping);

<span class="comment">// Trigger the events. Both listeners are called.</span>
ourObject.trigger(<span class="string"><span class="delimiter">&quot;</span><span class="content">move</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Yeah!</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Removes specified listener</span>
ourObject.off(<span class="string"><span class="delimiter">&quot;</span><span class="content">move</span><span class="delimiter">&quot;</span></span>, dancing);

<span class="comment">// Trigger the events again. One listener left.</span>
ourObject.trigger(<span class="string"><span class="delimiter">&quot;</span><span class="content">move</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Yeah, jump, jump!</span><span class="delimiter">&quot;</span></span>);
</pre></div>
</div>
</div>

<p><code>trigger()</code> peut passer plusieurs arguments à une fonction callback</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> ourObject = {};

<span class="comment">// Mixin</span>
_.extend(ourObject, Backbone.Events);

<span class="keyword">function</span> <span class="function">doAction</span> (action, duration) {
  console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">We are </span><span class="delimiter">&quot;</span></span> + action + <span class="string"><span class="delimiter">'</span><span class="content"> for </span><span class="delimiter">'</span></span> + duration ); 
}

<span class="comment">// Add event listeners</span>
ourObject.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">dance</span><span class="delimiter">&quot;</span></span>, doAction);
ourObject.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">jump</span><span class="delimiter">&quot;</span></span>, doAction);
ourObject.on(<span class="string"><span class="delimiter">&quot;</span><span class="content">skip</span><span class="delimiter">&quot;</span></span>, doAction);

<span class="comment">// Passing multiple arguments to single event</span>
ourObject.trigger(<span class="string"><span class="delimiter">&quot;</span><span class="content">dance</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">dancing</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">5 minutes</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Passing multiple arguments to multiple events</span>
ourObject.trigger(<span class="string"><span class="delimiter">&quot;</span><span class="content">dance jump skip</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">on fire</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">15 minutes</span><span class="delimiter">&quot;</span></span>);
</pre></div>
</div>
</div>

<p><code>listenTo()</code> et <code>stopListening()</code> permet à un objet {d’écouter/ arrêter d’écouter} les événements sur un autre objet.</p>

<p><em>Chaque fois qu’on fait <code>on()</code> sur un objet on doit faire aussi <code>off()</code></em>, sinon quand on supprimer un Model il va rester en mémoire. <code>View.remove()</code> fait un appel à <code>stopListening()</code> afin de s’assurer que tous les écouteurs sont déliées.</p>

<h3 id="events-et-views">Events et Views</h3>

<p>2 types d’événements peuvent être lié à une View :
- événements DOM (via jQuery.on() this va faire référence à l’objet DOM)
- événements déclenché via une API Event (via la propriété events{} this fait référence à la View)</p>

<h2 id="routers">Routers</h2>

<p>Connecte des URLs à des parties de l’application. Nécessaire si tu veux que certaines parties de ton application soient : mise dans les favoris, partageable, si tu veux pouvoir faire un Back avec le bouton back du navigateur.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">var</span> TodoRouter = Backbone.Router.extend({
    <span class="key">routes</span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">search/:query/p:page</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">searchTodos</span><span class="delimiter">&quot;</span></span>
        <span class="comment">// http://example.com/#search/job/p1</span>
    }
});
<span class="keyword">var</span> myTodoRouter = <span class="keyword">new</span> TodoRouter();
</pre></div>
</div>
</div>

<p><code>Backbone.history.start();</code> dit à Backbone qu’il fait observer tout changement de hash dans l’URL (d’où le /# hyper vitale)</p>

]]></content>
  </entry>
  
</feed>
